/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "rpcdb.h"

bool_t
xdr_status (XDR *xdrs, status *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_sensor_data (XDR *xdrs, sensor_data *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->sensor_id))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->values.values_val, (u_int *) &objp->values.values_len, ~0,
		sizeof (float), (xdrproc_t) xdr_float))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_sensor_stat (XDR *xdrs, sensor_stat *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->sensor_id))
		 return FALSE;
	 if (!xdr_float (xdrs, &objp->min))
		 return FALSE;
	 if (!xdr_float (xdrs, &objp->max))
		 return FALSE;
	 if (!xdr_float (xdrs, &objp->avg))
		 return FALSE;
	 if (!xdr_float (xdrs, &objp->med))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_command_type (XDR *xdrs, command_type *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_login_response (XDR *xdrs, login_response *objp)
{
	register int32_t *buf;

	 if (!xdr_status (xdrs, &objp->response))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->session_key))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_basic_response (XDR *xdrs, basic_response *objp)
{
	register int32_t *buf;

	 if (!xdr_status (xdrs, &objp->response))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_sensor_response (XDR *xdrs, sensor_response *objp)
{
	register int32_t *buf;

	 if (!xdr_status (xdrs, &objp->response))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->values.values_val, (u_int *) &objp->values.values_len, ~0,
		sizeof (float), (xdrproc_t) xdr_float))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_sensors_response (XDR *xdrs, sensors_response *objp)
{
	register int32_t *buf;

	 if (!xdr_status (xdrs, &objp->response))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, ~0,
		sizeof (sensor_data), (xdrproc_t) xdr_sensor_data))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_stat_response (XDR *xdrs, stat_response *objp)
{
	register int32_t *buf;

	 if (!xdr_status (xdrs, &objp->response))
		 return FALSE;
	 if (!xdr_sensor_stat (xdrs, &objp->stat))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_stats_response (XDR *xdrs, stats_response *objp)
{
	register int32_t *buf;

	 if (!xdr_status (xdrs, &objp->response))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->stats.stats_val, (u_int *) &objp->stats.stats_len, ~0,
		sizeof (sensor_stat), (xdrproc_t) xdr_sensor_stat))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_bad_response (XDR *xdrs, bad_response *objp)
{
	register int32_t *buf;

	 if (!xdr_status (xdrs, &objp->response))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_login_request (XDR *xdrs, login_request *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->username, USERNAME_SIZE))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_logout_request (XDR *xdrs, logout_request *objp)
{
	register int32_t *buf;

	 if (!xdr_u_quad_t (xdrs, &objp->session_key))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->username, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_basic_request (XDR *xdrs, basic_request *objp)
{
	register int32_t *buf;

	 if (!xdr_u_quad_t (xdrs, &objp->session_key))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_add_update_request (XDR *xdrs, add_update_request *objp)
{
	register int32_t *buf;

	 if (!xdr_u_quad_t (xdrs, &objp->session_key))
		 return FALSE;
	 if (!xdr_sensor_data (xdrs, &objp->data))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_sensor_request (XDR *xdrs, sensor_request *objp)
{
	register int32_t *buf;

	 if (!xdr_u_quad_t (xdrs, &objp->session_key))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sensor_id))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_sensors_request (XDR *xdrs, sensors_request *objp)
{
	register int32_t *buf;

	 if (!xdr_u_quad_t (xdrs, &objp->session_key))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->sensors.sensors_val, (u_int *) &objp->sensors.sensors_len, ~0,
		sizeof (sensor_data), (xdrproc_t) xdr_sensor_data))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_request (XDR *xdrs, request *objp)
{
	register int32_t *buf;

	 if (!xdr_command_type (xdrs, &objp->type))
		 return FALSE;
	switch (objp->type) {
	case LOGIN_CMD:
		 if (!xdr_login_request (xdrs, &objp->request_u.login))
			 return FALSE;
		break;
	case LOGOUT_CMD:
		 if (!xdr_logout_request (xdrs, &objp->request_u.logout))
			 return FALSE;
		break;
	case LOAD_CMD:
		 if (!xdr_sensors_request (xdrs, &objp->request_u.load))
			 return FALSE;
		break;
	case ADD_CMD:
	case UPDATE_CMD:
		 if (!xdr_add_update_request (xdrs, &objp->request_u.empty))
			 return FALSE;
		break;
	case DELETE_CMD:
	case READ_CMD:
	case GET_STAT_CMD:
		 if (!xdr_sensor_request (xdrs, &objp->request_u.existing))
			 return FALSE;
		break;
	case STORE_CMD:
	case READ_ALL_CMD:
	case GET_STAT_ALL_CMD:
		 if (!xdr_basic_request (xdrs, &objp->request_u.everything))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

bool_t
xdr_response (XDR *xdrs, response *objp)
{
	register int32_t *buf;

	 if (!xdr_command_type (xdrs, &objp->type))
		 return FALSE;
	switch (objp->type) {
	case LOGIN_CMD:
		 if (!xdr_login_response (xdrs, &objp->response_u.login))
			 return FALSE;
		break;
	case ADD_CMD:
	case UPDATE_CMD:
	case DELETE_CMD:
	case LOAD_CMD:
	case LOGOUT_CMD:
		 if (!xdr_basic_response (xdrs, &objp->response_u.active))
			 return FALSE;
		break;
	case GET_STAT_CMD:
		 if (!xdr_stat_response (xdrs, &objp->response_u.get_stat))
			 return FALSE;
		break;
	case GET_STAT_ALL_CMD:
		 if (!xdr_stats_response (xdrs, &objp->response_u.get_stat_all))
			 return FALSE;
		break;
	case READ_CMD:
		 if (!xdr_sensor_response (xdrs, &objp->response_u.read))
			 return FALSE;
		break;
	case STORE_CMD:
	case READ_ALL_CMD:
		 if (!xdr_sensors_response (xdrs, &objp->response_u.read_all))
			 return FALSE;
		break;
	case BAD_CMD:
		 if (!xdr_bad_response (xdrs, &objp->response_u.bad))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}
